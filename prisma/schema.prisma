generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                    String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email                 String    @unique @db.VarChar(255)
  username              String    @unique @db.VarChar(50)
  password_hash         String    @default("") @db.VarChar(255)
  avatar_url            String?
  bio                   String?
  xp                    Int       @default(0)
  level                 Int       @default(1)
  streak_days           Int       @default(0)
  last_read_at          DateTime? @db.Timestamptz(6)
  default_source        String?   @db.VarChar(50)
  notification_settings Json      @default("{\"push\": false, \"email\": true}")
  privacy_settings      Json      @default("{\"library_public\": false, \"activity_public\": false}")
  safe_browsing_mode    String    @default("sfw") @db.VarChar(20)

  safe_browsing_indicator String    @default("toggle") @db.VarChar(20)
  active_days             Int       @default(0)
  last_active_date        DateTime? @db.Timestamptz(6)
  subscription_tier       String    @default("free") @db.VarChar(20)
  subscription_expires_at DateTime? @db.Timestamptz(6)
  feed_last_seen_at       DateTime? @db.Timestamptz(6)
  created_at              DateTime  @default(now()) @db.Timestamptz(6)
  updated_at              DateTime  @default(now()) @updatedAt @db.Timestamptz(6)
  chapters_read           Int       @default(0)
  longest_streak          Int       @default(0)
  notification_digest     String    @default("immediate") @db.VarChar(20) // immediate, short, hourly, daily
  deleted_at              DateTime? @db.Timestamptz(6) // BUG 50: Soft Delete support

  // Anime-Style Seasonal XP System (Quarterly)
  // Format: "YYYY-Q[1-4]" where Q1=Winter(Jan-Mar), Q2=Spring(Apr-Jun), Q3=Summer(Jul-Sep), Q4=Fall(Oct-Dec)
  season_xp      Int     @default(0)
  current_season String? @db.VarChar(10) // Format: "YYYY-Q1" through "YYYY-Q4"

  // Trust Score System (Anti-Cheat)
  // RULES: Range 0.5-1.0, default 1.0, affects leaderboard only (effective_xp = xp * trust_score)
  trust_score            Float     @default(1.0) // Range: 0.5-1.0
  trust_score_updated_at DateTime? @db.Timestamptz(6)

  // Last XP award timestamp for rate limiting
  last_xp_award_at DateTime? @db.Timestamptz(6)

  activities Activity[]

  followers               Follow[]                     @relation("follower")
  following               Follow[]                     @relation("following")
  import_jobs             ImportJob[]
  library_entries         LibraryEntry[]
  triggered_notifications Notification[]               @relation("actor")
  notifications           Notification[]
  notification_queue      NotificationQueue[]
  achievements            UserAchievement[]
  seasonal_achievements   SeasonalUserAchievement[]
  chapter_reads           UserChapterRead[]
  chapter_reads_v2        UserChapterReadV2[]
  digest_buffer           NotificationDigestBuffer[]
  audit_logs              AuditLog[]
  source_priorities       UserSourcePriority[]
  series_preferences      UserSeriesSourcePreference[]
  recommendations         UserRecommendation[]
  signals                 UserSignal[]
  affinities              UserAffinity[]
  trust_violations        TrustViolation[]
  season_xp_history       UserSeasonXP[]
  read_telemetry          ReadTelemetry[]
  xp_transactions         XpTransaction[]

  // Chapter Links feature relations
  submitted_links       ChapterLink[]       @relation("submitted_links")
  verified_links        ChapterLink[]       @relation("verified_links")
  link_reports          ChapterLinkReport[]
  link_votes            LinkVote[]
  dmca_processed        DmcaRequest[]       @relation("dmca_processor")
  link_audit_actions    LinkSubmissionAudit[]
  blacklist_entries     DomainBlacklist[]

  @@index([username])
  @@index([xp(sort: Desc)])
  @@index([season_xp(sort: Desc)])
  @@map("users")
}

// Trust violation log for audit trail and recovery
model TrustViolation {
  id             String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id        String   @db.Uuid
  violation_type String   @db.VarChar(50) // rapid_reads, api_spam, status_toggle, large_jump
  severity       Float // Penalty amount (e.g., 0.05 = 5% reduction)
  previous_score Float
  new_score      Float
  metadata       Json? // Context about the violation
  created_at     DateTime @default(now()) @db.Timestamptz(6)

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id, created_at(sort: Desc)])
  @@index([violation_type, created_at(sort: Desc)])
  @@map("trust_violations")
}

model AuditLog {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id    String?  @db.Uuid
  event      String   @db.VarChar(100)
  status     String   @db.VarChar(20) // success, failure
  ip_address String?  @db.VarChar(45)
  user_agent String?
  metadata   Json?
  created_at DateTime @default(now()) @db.Timestamptz(6)

  user User? @relation(fields: [user_id], references: [id], onDelete: SetNull)

  @@index([user_id, created_at(sort: Desc)])
  @@index([event, created_at(sort: Desc)])
  @@map("audit_logs")
}

model LoginAttempt {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email        String   @db.VarChar(255)
  ip_address   String   @db.VarChar(45)
  success      Boolean  @default(false)
  attempted_at DateTime @default(now()) @db.Timestamptz(6)

  @@index([email, attempted_at(sort: Desc)])
  @@index([ip_address, attempted_at(sort: Desc)])
  @@map("login_attempts")
}

model Series {
  id                    String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  mangadex_id           String?        @unique @db.VarChar(255)
  title                 String         @db.VarChar(500)
  alternative_titles    Json           @default("[]")
  description           String?
  cover_url             String?
  best_cover_url        String?
  type                  String         @db.VarChar(20)
  status                String?        @db.VarChar(20)
  genres                String[]       @db.VarChar(50)
  content_rating        String?        @db.VarChar(20)
  total_follows         Int            @default(0)
  total_views           Int            @default(0)
  average_rating        Decimal?       @db.Decimal(3, 2)
  tags                  String[]       @db.VarChar(50)
  themes                String[]       @db.VarChar(50)
  format_tags           String[]       @db.VarChar(50)
  demographic           String?        @db.VarChar(50)
  original_language     String?        @db.VarChar(10)
  translated_languages  String[]       @db.VarChar(10)
  year                  Int?
  release_year          Int?
  external_links        Json?
  chapter_count         Int?
  latest_chapter        Decimal?       @db.Decimal(10, 2)
  last_chapter_at       DateTime?      @db.Timestamptz(6)
  first_chapter_date    DateTime?      @db.Timestamptz(6)
  last_chapter_date     DateTime?      @db.Timestamptz(6)
  last_synced_at        DateTime?      @db.Timestamptz(6)
  catalog_tier          CatalogTier    @default(C)
  tier_promoted_at      DateTime?      @db.Timestamptz(6)
  tier_reason           String?        @db.VarChar(100)
  activity_score        Int            @default(0)
  last_activity_at      DateTime?      @db.Timestamptz(6)
  metadata_source       MetadataSource @default(INFERRED)
  metadata_confidence   Float          @default(0.0)
  override_user_id      String?        @db.Uuid
  import_status         ImportStatus   @default(SOURCE_LINKED)
  original_import_title String?        @db.VarChar(500)

  rating_count        Int?
  rating_distribution Json?
  content_warnings    String[]  @db.VarChar(100)
  deleted_at          DateTime? @db.Timestamptz(6) // BUG 50: Soft Delete support
  created_at          DateTime  @default(now()) @db.Timestamptz(6)

  // Bug 10: Metadata schema versioning
  // Increment this constant when metadata shape changes to trigger re-validation
  metadata_schema_version Int @default(1)

  // MangaUpdates Integration Fields
  // Use official API V1 — do not scrape.
  // Run `prisma migrate dev` after adding these fields.
  mangaupdates_series_id BigInt?   @unique @map("mangaupdates_series_id")
  mu_metadata            Json?     @map("mu_metadata")
  mu_last_fetched_at     DateTime? @map("mu_last_fetched_at") @db.Timestamptz(6)

  // MangaDex Statistics Tracking
  stats_last_fetched_at  DateTime? @map("stats_last_fetched_at") @db.Timestamptz(6)

  // Canonical Series Deduplication
  // Links variant series (e.g., fan-translations) to canonical series for search deduplication
  canonical_series_id    String?   @db.Uuid
  canonical_series       Series?   @relation("canonical_variants", fields: [canonical_series_id], references: [id], onDelete: SetNull)
  variants               Series[]  @relation("canonical_variants")
  
  // Feed Ingest System
  // Kenmei-style: MAX(discovered_at) across all official feed sources
  // Updated atomically via GREATEST() to prevent race conditions
  last_chapter_released_at DateTime? @db.Timestamptz(6)

  updated_at          DateTime                     @default(now()) @updatedAt @db.Timestamptz(6)
  activities          Activity[]
  legacy_chapters     LegacyChapter[]
  chapters            Chapter[]
  library_entries     LibraryEntry[]
  notifications       Notification[]
  notification_queue  NotificationQueue[]
  sources             SeriesSource[]
  creators            SeriesCreator[]
  relations           SeriesRelation[]             @relation("series_relations")
  related_to          SeriesRelation[]             @relation("related_series")
  stats               SeriesStats?
  digest_buffer       NotificationDigestBuffer[]
  feed_entries        FeedEntry[]
  source_preferences  UserSeriesSourcePreference[]
  import_items        ImportItem[]
  activity_events     SeriesActivityEvent[]
  availability_events ChapterAvailability[]
  recommendations     UserRecommendation[]
  seed_list_entries   SeedListEntry[]
  user_signals        UserSignal[]
  read_telemetry      ReadTelemetry[]
  mangaupdates_releases MangaUpdatesRelease[]
  
  // Chapter Links feature
  chapter_links       ChapterLink[]
  dmca_requests       DmcaRequest[]
  
  // Feed Ingest events
  chapter_availability_events ChapterAvailabilityEvent[]

  @@index([title])
  @@index([status])
  @@index([type])
  @@index([total_follows(sort: Desc)])
  @@index([metadata_schema_version])
  @@index([last_chapter_released_at(sort: Desc)])
  @@map("series")
}

model SeriesSource {
  id                   String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  series_id            String?         @db.Uuid
  source_name          String          @db.VarChar(50)
  source_id            String          @db.VarChar(5000)
  source_url           String
  source_title         String?         @db.VarChar(500)
  source_chapter_count Int?
  trust_score          Decimal         @default(5.0) @db.Decimal(3, 2)
  last_checked_at      DateTime?       @db.Timestamptz(6)
  last_success_at      DateTime?       @db.Timestamptz(6)
  failure_count        Int             @default(0)
  match_confidence     Int?
  sync_priority        String          @default("COLD") @db.VarChar(10)
  next_check_at        DateTime?       @default(now()) @db.Timestamptz(6)
  cover_url            String?
  cover_width          Int?
  cover_height         Int?
  cover_updated_at     DateTime?       @db.Timestamptz(6)
  is_primary_cover     Boolean         @default(false)
  source_status        SourceStatus    @default(active)
  created_at           DateTime        @default(now()) @db.Timestamptz(6)

  // Bug 5: Source-level metadata tracking (series-scoped metadata)
  // This allows shared metadata resolution across users adding the same source
  metadata_status           String    @default("pending") @db.VarChar(20) // pending, enriched, unavailable, failed
  metadata_retry_count      Int       @default(0)
  last_metadata_error       String?
  last_metadata_attempt_at  DateTime? @db.Timestamptz(6)
  metadata_enriched_at      DateTime? @db.Timestamptz(6)

  legacy_chapters      LegacyChapter[]
  chapter_sources      ChapterSource[]
  series               Series?         @relation(fields: [series_id], references: [id], onDelete: SetNull)

  @@unique([source_name, source_id])
  @@index([series_id])
  @@index([sync_priority, next_check_at])
  @@index([metadata_status, last_metadata_attempt_at])
  @@map("series_sources")
}

// Legacy chapter model (source-coupled) - kept for backward compatibility
model LegacyChapter {
  id                String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  series_id         String?           @db.Uuid
  series_source_id  String            @db.Uuid
  chapter_number    Decimal           @db.Decimal(10, 2)
  chapter_title     String?           @db.VarChar(500)
  volume_number     Int?
  chapter_url       String
  is_available      Boolean           @default(true)
  page_count        Int?
  published_at      DateTime?         @db.Timestamptz(6)
  discovered_at     DateTime          @default(now()) @db.Timestamptz(6)
  scanlation_group  String?           @db.VarChar(255)
  language          String?           @db.VarChar(10)
  source_chapter_id String?           @db.VarChar(5000)
  activities        Activity[]
  series            Series?           @relation(fields: [series_id], references: [id], onDelete: SetNull)
  source            SeriesSource      @relation(fields: [series_source_id], references: [id], onDelete: Cascade)
  notifications     Notification[]
  user_reads        UserChapterRead[]

  @@unique([series_source_id, chapter_number])
  @@index([series_id, chapter_number(sort: Desc)])
  @@index([series_source_id, chapter_number(sort: Desc)])
  @@index([series_id, published_at(sort: Desc)])
  @@index([published_at(sort: Desc)])
  @@index([series_id, discovered_at(sort: Desc)])
  @@map("legacy_chapters")
}

// New logical chapter model (source-independent)
// MANGATRACK PARITY: Logical chapters are containers identified by (series_id, chapter_number)
model Chapter {
  id                String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  series_id         String?   @db.Uuid
  chapter_number    String    @db.VarChar(100)
  chapter_slug      String    @default("") @db.VarChar(100)
  volume_number     Int?
  chapter_title     String?   @db.VarChar(500)
  page_count        Int?
  published_at      DateTime? @db.Timestamptz(6)
  first_detected_at DateTime  @default(now()) @map("first_seen_at") @db.Timestamptz(6)
  read_at           DateTime? @db.Timestamptz(6)
  deleted_at        DateTime? @db.Timestamptz(6) // BUG 50: Soft Delete support
  updated_at        DateTime  @default(now()) @updatedAt @db.Timestamptz(6)

  series             Series?             @relation(fields: [series_id], references: [id], onDelete: SetNull)
  sources            ChapterSource[]
  user_reads         UserChapterReadV2[]
  notifications      Notification[]
  notification_queue NotificationQueue[]
  activities         Activity[]
  feed_entries       FeedEntry[]
  
  // Chapter Links feature
  chapter_links      ChapterLink[]

  // MANGATRACK PARITY: Identity is strictly (series_id, chapter_number)
  @@unique([series_id, chapter_number], name: "series_id_chapter_number")
  @@index([series_id, chapter_number(sort: Desc)])
  @@index([series_id, published_at(sort: Desc)])
  @@index([first_detected_at(sort: Desc)])
  // Cursor pagination indexes
  @@index([published_at(sort: Desc), id(sort: Desc)])
  @@index([first_detected_at(sort: Desc), id(sort: Desc)])
  @@index([published_at(sort: Desc), series_id])
  @@map("logical_chapters")
}

// Chapter availability from a specific source
// MANGATRACK PARITY: Each source upload is a separate availability event
model ChapterSource {
  id                  String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  chapter_id          String              @db.Uuid
  series_source_id    String              @db.Uuid
  source_name         String              @db.VarChar(50)
  source_chapter_id   String?             @db.VarChar(5000)
  source_chapter_url  String
  chapter_title       String?             @db.VarChar(500)
  is_available        Boolean             @default(true)
  is_preferred        Boolean             @default(false)
  page_count          Int?
  scanlation_group    String?             @db.VarChar(255)
  language            String?             @db.VarChar(10)
  source_published_at DateTime?           @db.Timestamptz(6)
  detected_at         DateTime            @default(now()) @db.Timestamptz(6)
  last_checked_at     DateTime?           @db.Timestamptz(6)
  chapter             Chapter             @relation(fields: [chapter_id], references: [id], onDelete: Cascade)
  series_source       SeriesSource        @relation(fields: [series_source_id], references: [id], onDelete: Cascade)
  user_reads          UserChapterReadV2[]

  // Deduplication: One entry per source per logical chapter
  @@unique([series_source_id, chapter_id])
  @@index([chapter_id])
  @@index([series_source_id])
  @@index([detected_at(sort: Desc)])
  @@index([chapter_id, is_available])
  @@map("chapter_sources")
}

// Legacy user chapter read (per legacy Chapter)
model UserChapterRead {
  id          String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id     String        @db.Uuid
  chapter_id  String        @db.Uuid
  source_used String?       @db.VarChar(50)
  read_at     DateTime      @default(now()) @db.Timestamptz(6)
  user        User          @relation(fields: [user_id], references: [id], onDelete: Cascade)
  chapter     LegacyChapter @relation(fields: [chapter_id], references: [id], onDelete: Cascade)

  @@unique([user_id, chapter_id])
  @@index([user_id, read_at(sort: Desc)])
  @@index([chapter_id])
  @@map("user_chapter_reads")
}

// New user chapter read (per LogicalChapter, NOT per source)
// MANGATRACK PARITY: Read status is stored per logical chapter_id
model UserChapterReadV2 {
  id                   String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id              String         @db.Uuid
  chapter_id           String         @db.Uuid
  source_used_id       String?        @db.Uuid
  source_name          String?        @db.VarChar(50)
  is_read              Boolean        @default(true)
  read_at              DateTime       @default(now()) @db.Timestamptz(6)
  updated_at           DateTime       @default(now()) @db.Timestamptz(6)
  server_received_at   DateTime       @default(now()) @db.Timestamptz(6)
  device_id            String?        @db.VarChar(100)
  pages_read           Int?
  reading_time_seconds Int?
  user                 User           @relation(fields: [user_id], references: [id], onDelete: Cascade)
  chapter              Chapter        @relation(fields: [chapter_id], references: [id], onDelete: Cascade)
  source_used          ChapterSource? @relation(fields: [source_used_id], references: [id], onDelete: SetNull)

  // Deduplication: User reads a chapter once (may re-read with different source)
  @@unique([user_id, chapter_id])
  @@index([user_id, updated_at(sort: Desc)])
  // Cursor pagination index
  @@index([user_id, updated_at(sort: Desc), id(sort: Desc)])
  @@index([chapter_id])
  @@map("user_chapter_reads_v2")
}

model LibraryEntry {
  /// INVARIANT: series_id is optional. source_url is the functional identity key.
  id                           String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id                      String         @db.Uuid
  series_id                    String?        @db.Uuid
  source_url                   String
  source_name                  String
  imported_title               String?
  metadata_status              MetadataStatus @default(pending)
  status                       String         @default("reading") @db.VarChar(20)
  last_read_chapter            Decimal?       @db.Decimal(10, 3)
  last_read_at                 DateTime?      @db.Timestamptz(6)
  user_rating                  Int?
  preferred_source             String?        @db.VarChar(50)
  notify_new_chapters          Boolean        @default(true)
  push_enabled                 Boolean        @default(false)
  notification_mode            String         @default("default") @db.VarChar(20) // default, immediate, digest, muted
  sync_priority                String         @default("WARM") @db.VarChar(10)
  deleted_at                   DateTime?      @db.Timestamptz(6) // BUG 50: Soft Delete support
  added_at                     DateTime       @default(now()) @db.Timestamptz(6)
  needs_review                 Boolean        @default(false)
  metadata_retry_count         Int            @default(0)
  last_metadata_error          String?
  last_metadata_attempt_at     DateTime?      @db.Timestamptz(6) // Track when last enrichment was attempted
  series_completion_xp_granted Boolean        @default(false)

  // Bug 9: Sync status tracking (independent from metadata_status)
  // Distinguishes chapter sync health from metadata resolution status
  sync_status     String    @default("healthy") @db.VarChar(20) // healthy, degraded, failed
  last_sync_error String?
  last_sync_at    DateTime? @db.Timestamptz(6)

  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  series     Series?  @relation(fields: [series_id], references: [id], onDelete: SetNull)
  user       User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, source_url])
  @@index([user_id])
  @@index([user_id, status, last_read_at(sort: Desc)])
  @@index([series_id, status])
  @@index([sync_priority, updated_at])
  @@index([metadata_status, last_metadata_attempt_at]) // Index for scheduled re-resolution
  @@index([sync_status, last_sync_at])
  @@map("library_entries")
}

model WorkerFailure {
  id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  queue_name    String    @db.VarChar(100)
  job_id        String    @db.VarChar(255)
  payload       Json
  error_message String?
  stack_trace   String?
  attempts_made Int
  resolved_at   DateTime? @db.Timestamptz(6)
  created_at    DateTime  @default(now()) @db.Timestamptz(6)

  @@index([queue_name, created_at(sort: Desc)])
  @@index([job_id])
  @@map("worker_failures")
}

model Notification {
  id                 String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id            String         @db.Uuid
  type               String         @db.VarChar(50)
  title              String         @db.VarChar(255)
  message            String?
  series_id          String?        @db.Uuid
  chapter_id         String?        @db.Uuid
  logical_chapter_id String?        @db.Uuid
  actor_user_id      String?        @db.Uuid
  metadata           Json?
  priority           Int?           @default(2)
  read_at            DateTime?      @db.Timestamptz(6)
  created_at         DateTime       @default(now()) @db.Timestamptz(6)
  actor              User?          @relation("actor", fields: [actor_user_id], references: [id])
  chapter            LegacyChapter? @relation(fields: [chapter_id], references: [id], onDelete: Cascade)
  logical_chapter    Chapter?       @relation(fields: [logical_chapter_id], references: [id], onDelete: Cascade)
  series             Series?        @relation(fields: [series_id], references: [id], onDelete: Cascade)
  user               User           @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id, created_at(sort: Desc)])
  @@index([user_id, read_at, created_at(sort: Desc)])
  @@map("notifications")
}

model Achievement {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  code        String   @unique @db.VarChar(50)
  name        String   @db.VarChar(100)
  description String?
  icon_url    String?
  xp_reward   Int
  rarity      String   @default("common") @db.VarChar(20)
  criteria    Json
  is_seasonal Boolean  @default(false)
  is_hidden   Boolean  @default(false)
  season_id   String?  @db.Uuid
  created_at  DateTime @default(now()) @db.Timestamptz(6)

  season            Season?                   @relation(fields: [season_id], references: [id], onDelete: SetNull)
  user_achievements UserAchievement[]
  seasonal_unlocks  SeasonalUserAchievement[]

  @@index([is_seasonal])
  @@index([is_hidden])
  @@index([season_id])
  @@map("achievements")
}

model UserAchievement {
  id             String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id        String      @db.Uuid
  achievement_id String      @db.Uuid
  unlocked_at    DateTime    @default(now()) @db.Timestamptz(6)
  achievement    Achievement @relation(fields: [achievement_id], references: [id], onDelete: Cascade)
  user           User        @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, achievement_id])
  @@index([user_id, unlocked_at(sort: Desc)])
  @@map("user_achievements")
}

model Follow {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  follower_id  String   @db.Uuid
  following_id String   @db.Uuid
  created_at   DateTime @default(now()) @db.Timestamptz(6)
  follower     User     @relation("follower", fields: [follower_id], references: [id], onDelete: Cascade)
  following    User     @relation("following", fields: [following_id], references: [id], onDelete: Cascade)

  @@unique([follower_id, following_id])
  @@index([follower_id])
  @@index([following_id])
  @@map("follows")
}

model Activity {
  id                 String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id            String         @db.Uuid
  type               String         @db.VarChar(50)
  series_id          String?        @db.Uuid
  chapter_id         String?        @db.Uuid
  logical_chapter_id String?        @db.Uuid
  achievement_id     String?        @db.Uuid
  metadata           Json?
  created_at         DateTime       @default(now()) @db.Timestamptz(6)
  chapter            LegacyChapter? @relation(fields: [chapter_id], references: [id], onDelete: Cascade)
  logical_chapter    Chapter?       @relation(fields: [logical_chapter_id], references: [id], onDelete: Cascade)
  series             Series?        @relation(fields: [series_id], references: [id], onDelete: Cascade)
  user               User           @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id, created_at(sort: Desc)])
  @@index([created_at(sort: Desc)])
  @@map("activities")
}

model ImportJob {
  id              String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id         String       @db.Uuid
  source          String       @db.VarChar(50)
  status          String       @default("pending") @db.VarChar(20)
  total_items     Int?
  processed_items Int          @default(0)
  matched_items   Int          @default(0)
  failed_items    Int          @default(0)
  error_log       Json?
  created_at      DateTime     @default(now()) @db.Timestamptz(6)
  completed_at    DateTime?    @db.Timestamptz(6)
  user            User         @relation(fields: [user_id], references: [id], onDelete: Cascade)
  items           ImportItem[]

  @@index([user_id, created_at(sort: Desc)])
  @@map("import_jobs")
}

model ImportItem {
  id             String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  job_id         String           @db.Uuid
  title          String           @db.VarChar(500)
  status         ImportItemStatus @default(PENDING)
  reason_code    String?          @db.VarChar(50)
  reason_message String?
  series_id      String?          @db.Uuid
  metadata       Json?

  job    ImportJob @relation(fields: [job_id], references: [id], onDelete: Cascade)
  series Series?   @relation(fields: [series_id], references: [id], onDelete: SetNull)

  @@index([job_id])
  @@index([status])
  @@map("import_items")
}

enum ImportItemStatus {
  PENDING
  SUCCESS
  FAILED
}

enum ImportStatus {
  SOURCE_LINKED
  CANONICALLY_ENRICHED
  METADATA_FAILED
}

// MetadataStatus enum with new 'unavailable' state
// - pending: Initial state, awaiting enrichment
// - enriched: Successfully linked to canonical metadata
// - unavailable: No match found, but entry is healthy (chapters can still sync)
// - failed: Permanent error during enrichment (e.g., invalid data)
enum MetadataStatus {
  pending
  enriched
  unavailable
  failed
}

enum SourceStatus {
  active
  inactive
  broken
  external_link
}

enum MetadataSource {
  CANONICAL
  USER_OVERRIDE
  INFERRED
}

enum CatalogTier {
  A
  B
  C
}

model NotificationDigestBuffer {
  id             String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id        String    @db.Uuid
  series_id      String    @db.Uuid
  chapter_number Decimal   @db.Decimal(10, 2)
  source_names   String[]  @db.VarChar(50)
  created_at     DateTime  @default(now()) @db.Timestamptz(6)
  updated_at     DateTime  @default(now()) @updatedAt @db.Timestamptz(6)
  flushed_at     DateTime? @db.Timestamptz(6)

  user   User   @relation(fields: [user_id], references: [id], onDelete: Cascade)
  series Series @relation(fields: [series_id], references: [id], onDelete: Cascade)

  @@unique([user_id, series_id, chapter_number, flushed_at])
  @@index([user_id, flushed_at])
  @@index([created_at])
  @@map("notification_digest_buffer")
}

model Creator {
  id          String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name        String          @db.VarChar(255)
  mangadex_id String?         @unique @db.VarChar(255)
  biography   String?
  image_url   String?
  created_at  DateTime        @default(now()) @db.Timestamptz(6)
  series      SeriesCreator[]

  @@map("creators")
}

model SeriesCreator {
  id         String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  series_id  String  @db.Uuid
  creator_id String  @db.Uuid
  role       String  @db.VarChar(50)
  series     Series  @relation(fields: [series_id], references: [id], onDelete: Cascade)
  creator    Creator @relation(fields: [creator_id], references: [id], onDelete: Cascade)

  @@unique([series_id, creator_id, role])
  @@index([series_id])
  @@index([creator_id])
  @@map("series_creators")
}

model SeriesRelation {
  id            String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  series_id     String @db.Uuid
  related_id    String @db.Uuid
  relation_type String @db.VarChar(50)
  series        Series @relation("series_relations", fields: [series_id], references: [id], onDelete: Cascade)
  related       Series @relation("related_series", fields: [related_id], references: [id], onDelete: Cascade)

  @@unique([series_id, related_id])
  @@index([series_id])
  @@index([related_id])
  @@map("series_relations")
}

model SeriesStats {
  id                String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  series_id         String   @unique @db.Uuid
  total_readers     Int      @default(0)
  readers_reading   Int      @default(0)
  readers_completed Int      @default(0)
  readers_planning  Int      @default(0)
  readers_dropped   Int      @default(0)
  readers_on_hold   Int      @default(0)
  total_ratings     Int      @default(0)
  rating_1          Int      @default(0)
  rating_2          Int      @default(0)
  rating_3          Int      @default(0)
  rating_4          Int      @default(0)
  rating_5          Int      @default(0)
  rating_6          Int      @default(0)
  rating_7          Int      @default(0)
  rating_8          Int      @default(0)
  rating_9          Int      @default(0)
  rating_10         Int      @default(0)
  weekly_readers    Int      @default(0)
  monthly_readers   Int      @default(0)
  popularity_rank   Int?
  trending_rank     Int?
  updated_at        DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  series            Series   @relation(fields: [series_id], references: [id], onDelete: Cascade)

  @@index([popularity_rank])
  @@index([trending_rank])
  @@map("series_stats")
}

model FeedEntry {
  id                  String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  series_id           String   @db.Uuid
  logical_chapter_id  String?  @db.Uuid
  chapter_number      Decimal  @db.Decimal(10, 2)
  sources             Json     @default("[]")
  first_discovered_at DateTime @default(now()) @db.Timestamptz(6)
  last_updated_at     DateTime @default(now()) @db.Timestamptz(6)
  created_at          DateTime @default(now()) @db.Timestamptz(6)
  series              Series   @relation(fields: [series_id], references: [id], onDelete: Cascade)
  logical_chapter     Chapter? @relation(fields: [logical_chapter_id], references: [id], onDelete: Cascade)

  // BUG FIX: Added unique constraint for upsert operations
  @@unique([series_id, chapter_number], name: "series_id_chapter_number")
  @@index([first_discovered_at(sort: Desc)])
  @@index([logical_chapter_id])
  @@index([last_updated_at(sort: Desc)])
  @@index([last_updated_at(sort: Desc), series_id])
  @@map("feed_entries")
}

model QueryStats {
  normalized_key   String    @id @db.VarChar(255)
  total_searches   Int       @default(0)
  unique_users     Int       @default(0)
  last_searched_at DateTime  @default(now()) @db.Timestamptz(6)
  last_enqueued_at DateTime? @db.Timestamptz(6)
  resolved         Boolean   @default(false)
  deferred         Boolean   @default(false)

  @@index([last_searched_at(sort: Desc)])
  @@map("query_stats")
}

model UserSourcePriority {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id     String   @db.Uuid
  source_name String   @db.VarChar(50)
  priority    Int // 0 is highest
  created_at  DateTime @default(now()) @db.Timestamptz(6)
  updated_at  DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, source_name])
  @@index([user_id, priority])
  @@map("user_source_priorities")
}

model UserSeriesSourcePreference {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id     String   @db.Uuid
  series_id   String   @db.Uuid
  source_name String   @db.VarChar(50)
  created_at  DateTime @default(now()) @db.Timestamptz(6)
  updated_at  DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  user   User   @relation(fields: [user_id], references: [id], onDelete: Cascade)
  series Series @relation(fields: [series_id], references: [id], onDelete: Cascade)

  @@unique([user_id, series_id])
  @@index([user_id, series_id])
  @@map("user_series_source_preferences")
}

model SeriesActivityEvent {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  series_id   String   @db.Uuid
  event_type  String   @db.VarChar(50) // chapter_detected, user_follow, user_read, update_click
  source_name String?  @db.VarChar(50) // Optional - which source triggered this
  weight      Int      @default(1)
  created_at  DateTime @default(now()) @db.Timestamptz(6)

  series Series @relation(fields: [series_id], references: [id], onDelete: Cascade)

  @@index([series_id, created_at(sort: Desc)])
  @@index([event_type, created_at(sort: Desc)])
  @@map("series_activity_events")
}

model SeedList {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name        String   @unique @db.VarChar(100) // e.g., "top_manhwa_2025", "classic_manga"
  description String?
  is_active   Boolean  @default(true)
  created_at  DateTime @default(now()) @db.Timestamptz(6)
  updated_at  DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  entries SeedListEntry[]

  @@map("seed_lists")
}

model SeedListEntry {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  seed_list_id String   @db.Uuid
  series_id    String   @db.Uuid
  added_at     DateTime @default(now()) @db.Timestamptz(6)

  seed_list SeedList @relation(fields: [seed_list_id], references: [id], onDelete: Cascade)
  series    Series   @relation(fields: [series_id], references: [id], onDelete: Cascade)

  @@unique([seed_list_id, series_id])
  @@map("seed_list_entries")
}

model NotificationQueue {
  id           String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id      String    @db.Uuid
  series_id    String    @db.Uuid
  chapter_id   String    @db.Uuid
  notify_after DateTime  @db.Timestamptz(6)
  sent_at      DateTime? @db.Timestamptz(6)
  created_at   DateTime  @default(now()) @db.Timestamptz(6)

  user    User    @relation(fields: [user_id], references: [id], onDelete: Cascade)
  series  Series  @relation(fields: [series_id], references: [id], onDelete: Cascade)
  chapter Chapter @relation(fields: [chapter_id], references: [id], onDelete: Cascade)

  @@unique([user_id, chapter_id])
  @@index([notify_after])
  @@index([sent_at])
  @@map("notifications_queue")
}

model UserRecommendation {
  user_id      String   @db.Uuid
  series_id    String   @db.Uuid
  score        Float
  reason       String
  generated_at DateTime @default(now()) @db.Timestamptz(6)

  user   User   @relation(fields: [user_id], references: [id], onDelete: Cascade)
  series Series @relation(fields: [series_id], references: [id], onDelete: Cascade)

  @@id([user_id, series_id])
  @@index([user_id, score(sort: Desc)])
  @@map("user_recommendations")
}

model UserSignal {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id     String   @db.Uuid
  series_id   String?  @db.Uuid
  signal_type String   @db.VarChar(50) // e.g., 'manga_click', 'add_to_library'
  weight      Float // Initial weight at time of creation
  metadata    Json? // Context: chapter_id, session_duration, source_name
  created_at  DateTime @default(now()) @db.Timestamptz(6)

  user   User    @relation(fields: [user_id], references: [id], onDelete: Cascade)
  series Series? @relation(fields: [series_id], references: [id], onDelete: SetNull)

  @@index([user_id, created_at])
  @@map("user_signals")
}

model UserAffinity {
  user_id         String   @db.Uuid
  attribute_type  String   @db.VarChar(50) // 'genre', 'theme', 'type', 'series_id'
  attribute_id    String   @db.VarChar(255) // The ID or Name (e.g., 'Action', 'Shonen')
  score           Float    @default(0)
  last_updated_at DateTime @default(now()) @db.Timestamptz(6)

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@id([user_id, attribute_type, attribute_id])
  @@index([user_id, score(sort: Desc)])
  @@map("user_affinities")
}

model ChapterAvailability {
  id             String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  series_id      String   @db.Uuid
  chapter_number Decimal  @db.Decimal(10, 2)
  source_id      String   @db.VarChar(50)
  source_name    String   @db.VarChar(100)
  source_url     String
  discovered_at  DateTime @default(now()) @db.Timestamptz(6)

  series Series @relation(fields: [series_id], references: [id], onDelete: Cascade)

  @@index([discovered_at(sort: Desc)])
  @@index([series_id, chapter_number])
  @@map("chapter_availability")
}

// =============================================================================
// FEED INGEST SYSTEM - Official Source Feed Tracking
// =============================================================================
// Tracks chapter releases from official API sources (MangaDex, MangaPlus, etc.)
// Used to update series.last_chapter_released_at atomically

model ChapterAvailabilityEvent {
  id               String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  series_id        String   @db.Uuid
  chapter_number   String   @db.VarChar(100) // Supports "10.5", "Special", etc.
  source_name      String   @db.VarChar(50)  // 'mangadex', 'mangaplus', 'webtoons'
  external_event_id String? @db.VarChar(255) // Source-specific ID for deduplication
  
  // Timestamps
  discovered_at    DateTime @default(now()) @db.Timestamptz(6) // When WE detected
  published_at     DateTime? @db.Timestamptz(6) // When source says it was published
  
  // Metadata
  chapter_title    String?  @db.VarChar(500)
  volume_number    Int?
  language         String   @default("en") @db.VarChar(10)
  external_url     String?  // Link to official source (not pirated)
  
  // Processing status
  processed_at     DateTime? @db.Timestamptz(6)
  process_status   String   @default("pending") @db.VarChar(20) // pending, processed, skipped, error
  process_error    String?
  
  // Audit
  raw_payload      Json     @default("{}") // Original API response for debugging
  created_at       DateTime @default(now()) @db.Timestamptz(6)
  
  series Series @relation(fields: [series_id], references: [id], onDelete: Cascade)

  // Unique constraint for idempotency
  @@unique([series_id, chapter_number, source_name, external_event_id])
  @@index([discovered_at(sort: Asc)])
  @@index([series_id, discovered_at(sort: Desc)])
  @@index([source_name, discovered_at(sort: Desc)])
  @@index([source_name, external_event_id])
  @@index([process_status, discovered_at(sort: Asc)])
  @@map("chapter_availability_events")
}

// Feed ingest job tracking for monitoring
model FeedIngestRun {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  source_name     String    @db.VarChar(50)
  tier            String    @default("A") @db.VarChar(1) // A, B, C for sync frequency
  
  // Run metrics
  started_at      DateTime  @default(now()) @db.Timestamptz(6)
  completed_at    DateTime? @db.Timestamptz(6)
  status          String    @default("running") @db.VarChar(20) // running, completed, failed
  
  // Results
  events_fetched  Int       @default(0)
  events_created  Int       @default(0)
  events_skipped  Int       @default(0) // Duplicates
  series_updated  Int       @default(0)
  
  // Errors
  error_message   String?
  error_count     Int       @default(0)
  
  // Rate limiting info
  rate_limit_hits Int       @default(0)
  api_calls_made  Int       @default(0)
  
  created_at      DateTime  @default(now()) @db.Timestamptz(6)

  @@index([source_name, started_at(sort: Desc)])
  @@index([status, started_at(sort: Asc)])
  @@map("feed_ingest_runs")
}

// ============================================================================
// GAMIFICATION MODELS
// ============================================================================

// Season model for anime-style quarterly seasons
// SEASON MODEL (LOCKED):
// - Winter: Jan 1 – Mar 31 (Q1)
// - Spring: Apr 1 – Jun 30 (Q2)
// - Summer: Jul 1 – Sep 30 (Q3)
// - Fall:   Oct 1 – Dec 31 (Q4)
model Season {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  code       String   @unique @db.VarChar(20) // Format: "YYYY-Q1" through "YYYY-Q4" (e.g., "2026-Q1" = Winter 2026)
  name       String   @db.VarChar(100) // Display name: "Winter 2026", "Spring 2026", etc.
  starts_at  DateTime @db.Timestamptz(6)
  ends_at    DateTime @db.Timestamptz(6)
  is_active  Boolean  @default(false)
  created_at DateTime @default(now()) @db.Timestamptz(6)

  achievements               Achievement[]
  seasonal_user_achievements SeasonalUserAchievement[]
  user_season_xp             UserSeasonXP[]

  @@index([starts_at, ends_at])
  @@index([is_active])
  @@map("seasons")
}

// Historical per-season XP tracking
// RULES:
// - Preserves XP history when seasons roll over
// - Enables historical leaderboards
// - User's current season XP is in users.season_xp (fast access)
// - This table stores archival/historical data
model UserSeasonXP {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id    String   @db.Uuid
  season_id  String   @db.Uuid
  xp         Int      @default(0)
  final_rank Int? // Populated at season end
  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @default(now()) @updatedAt @db.Timestamptz(6)

  user   User   @relation(fields: [user_id], references: [id], onDelete: Cascade)
  season Season @relation(fields: [season_id], references: [id], onDelete: Cascade)

  @@unique([user_id, season_id])
  @@index([season_id, xp(sort: Desc)])
  @@index([user_id, created_at(sort: Desc)])
  @@map("user_season_xp")
}

// Seasonal achievements - unlocked once per season per user
model SeasonalUserAchievement {
  id             String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id        String   @db.Uuid
  achievement_id String   @db.Uuid
  season_id      String   @db.Uuid
  unlocked_at    DateTime @default(now()) @db.Timestamptz(6)

  user        User        @relation(fields: [user_id], references: [id], onDelete: Cascade)
  achievement Achievement @relation(fields: [achievement_id], references: [id], onDelete: Cascade)
  season      Season      @relation(fields: [season_id], references: [id], onDelete: Cascade)

  // User can unlock same achievement once per season
  @@unique([user_id, achievement_id, season_id])
  @@index([user_id, unlocked_at(sort: Desc)])
  @@index([season_id])
  @@map("seasonal_user_achievements")
}

// Read telemetry for anti-cheat detection (detection only, not blocking)
// RULES (LOCKED):
// 1. Telemetry is for detection only - NEVER blocks reads
// 2. flagged=true signals suspicious activity for trust_score evaluation
// 3. Data is used to refine trust score algorithms
// 4. Retention: 90 days (older records can be pruned)
model ReadTelemetry {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id         String   @db.Uuid
  series_id       String   @db.Uuid
  chapter_number  Int // Integer chapter number for simplicity
  read_duration_s Int // Time spent reading in seconds
  page_count      Int? // Number of pages if known
  flagged         Boolean  @default(false) // True if read was suspiciously fast
  flag_reason     String?  @db.VarChar(50) // e.g., "speed_read", "bulk_speed_read"
  device_id       String?  @db.VarChar(100)
  created_at      DateTime @default(now()) @db.Timestamptz(6)

  user   User   @relation(fields: [user_id], references: [id], onDelete: Cascade)
  series Series @relation(fields: [series_id], references: [id], onDelete: Cascade)

  @@index([user_id, created_at(sort: Desc)])
  @@index([series_id, created_at(sort: Desc)])
  @@index([flagged, created_at(sort: Desc)])
  @@map("read_telemetry")
}

// XP Transaction log for audit trail (migration bonuses, etc.)
// RULES (LOCKED):
// 1. INSERT ONLY - transactions are never updated or deleted
// 2. One migration_bonus per user (enforced by unique constraint)
// 3. Source identifies the type: 'migration_bonus', 'chapter_read', 'achievement', etc.
model XpTransaction {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id     String   @db.Uuid
  amount      Int
  source      String   @db.VarChar(50) // migration_bonus, chapter_read, achievement, etc.
  source_id   String?  @db.VarChar(255) // Unique identifier for the source (e.g., import_123456)
  description String?
  created_at  DateTime @default(now()) @db.Timestamptz(6)

  user User @relation(fields: [user_id], references: [id], onDelete: Cascade)

  // Unique constraint for one-time bonuses (migration_bonus per user)
  @@unique([user_id, source], name: "user_id_source_unique")
  @@index([user_id, created_at(sort: Desc)])
  @@index([source, created_at(sort: Desc)])
  @@map("xp_transactions")
}

// =============================================================================
// METADATA SCHEMA VERSION CONSTANT
// =============================================================================
// When metadata shape changes:
// 1. Increment CURRENT_METADATA_SCHEMA_VERSION in lib/constants/metadata.ts
// 2. Update the index in Series model to filter outdated entries
// 3. Metadata healing scheduler will re-enrich entries with old versions

// =============================================================================
// MANGAUPDATES INTEGRATION MODELS
// =============================================================================
// Use official API V1 — do not scrape.
// Run `prisma migrate dev --name add_mangaupdates_integration` after adding.

model MangaUpdatesRelease {
  id                      String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  mangaupdates_release_id String    @unique @map("mangaupdates_release_id") @db.VarChar(100)
  mangaupdates_series_id  BigInt    @map("mangaupdates_series_id")
  series_id               String?   @map("series_id") @db.Uuid
  title                   String    @db.VarChar(500)
  chapter                 String?   @db.VarChar(50)
  volume                  String?   @db.VarChar(50)
  language                String?   @db.VarChar(10)
  published_at            DateTime? @map("published_at") @db.Timestamptz(6)
  metadata                Json?
  created_at              DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)

  series Series? @relation(fields: [series_id], references: [id], onDelete: SetNull)

  @@index([mangaupdates_series_id])
  @@index([series_id])
  @@index([published_at(sort: Desc)])
  @@index([created_at(sort: Desc)])
  @@map("mangaupdates_releases")
}

// =============================================================================
// PUBLIC CHAPTER LINKS FEATURE
// =============================================================================
// User-submitted and auto-linked chapter URLs with abuse protection
// RULES:
// 1. Max 3 visible links per chapter (enforced by DB trigger + advisory lock)
// 2. Deduplication via SHA256 hash of normalized URL
// 3. Reputation-weighted reporting (trust_score affects report weight)
// 4. Auto-hide links when report_score >= 3
// 5. Append-only audit log for Safe Harbor compliance

// Link status enum
enum ChapterLinkStatus {
  unverified  // User-submitted, pending moderation
  visible     // Active and displayed
  hidden      // Hidden by reports but not removed
  removed     // Removed by admin/DMCA

  @@map("chapter_link_status")
}

// Report reason enum
enum LinkReportReason {
  broken      // Link is dead/404
  malicious   // Malware/phishing
  spam        // Spam/advertisement
  copyright   // DMCA/copyright claim
  other       // Other reason

  @@map("link_report_reason")
}

// Main chapter links table
model ChapterLink {
  id               String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  series_id        String            @db.Uuid
  chapter_id       String?           @db.Uuid
  chapter_number   String            @db.VarChar(100)
  source_name      String            // Normalized: 'mangadex', 'mangapark', 'viz'
  url              String
  url_normalized   String            // Lowercase, trimmed, protocol-stripped
  url_hash         String            @db.Char(64) // SHA256(url_normalized)
  status           ChapterLinkStatus @default(unverified)
  visibility_score Int               @default(0) // upvotes - downvotes
  submitted_by     String?           @db.Uuid
  submitted_at     DateTime          @default(now()) @db.Timestamptz(6)
  verified_by      String?           @db.Uuid
  verified_at      DateTime?         @db.Timestamptz(6)
  last_report_score Int              @default(0) // Weighted sum of active reports
  deleted_at       DateTime?         @db.Timestamptz(6)
  metadata         Json              @default("{}") // { displayName, domain, note, scanlationGroup }

  series    Series   @relation(fields: [series_id], references: [id], onDelete: Cascade)
  chapter   Chapter? @relation(fields: [chapter_id], references: [id], onDelete: SetNull)
  submitter User?    @relation("submitted_links", fields: [submitted_by], references: [id], onDelete: SetNull)
  verifier  User?    @relation("verified_links", fields: [verified_by], references: [id], onDelete: SetNull)
  reports   ChapterLinkReport[]
  votes     LinkVote[]
  audits    LinkSubmissionAudit[]
  dmca_requests DmcaRequest[]

  // Indexes are created in migration SQL for complex expressions
  @@index([url_hash])
  @@index([source_name])
  @@map("chapter_links")
}

// User reports on chapter links
model ChapterLinkReport {
  id              String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  chapter_link_id String           @db.Uuid
  reporter_id     String           @db.Uuid
  reason          LinkReportReason
  details         String?
  weight          Int              @default(1) // Based on reporter trust_score
  created_at      DateTime         @default(now()) @db.Timestamptz(6)
  resolved_at     DateTime?        @db.Timestamptz(6)
  resolution_note String?

  link     ChapterLink @relation(fields: [chapter_link_id], references: [id], onDelete: Cascade)
  reporter User        @relation(fields: [reporter_id], references: [id], onDelete: Cascade)

  @@unique([chapter_link_id, reporter_id])
  @@index([chapter_link_id, created_at(sort: Desc)])
  @@index([reporter_id, created_at(sort: Desc)])
  @@map("chapter_link_reports")
}

// User upvotes/downvotes on chapter links
model LinkVote {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  chapter_link_id String   @db.Uuid
  user_id         String   @db.Uuid
  vote            Int      // 1 = upvote, -1 = downvote
  created_at      DateTime @default(now()) @db.Timestamptz(6)
  updated_at      DateTime @default(now()) @db.Timestamptz(6)

  link ChapterLink @relation(fields: [chapter_link_id], references: [id], onDelete: Cascade)
  user User        @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([chapter_link_id, user_id])
  @@index([chapter_link_id])
  @@index([user_id, created_at(sort: Desc)])
  @@map("link_votes")
}

// DMCA takedown requests
model DmcaRequest {
  id                String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  requester_contact String    // Email or contact info
  requester_name    String?
  requester_company String?
  target_url        String?   // URL being claimed
  target_link_id    String?   @db.Uuid
  target_series_id  String?   @db.Uuid
  work_title        String?   // Title of copyrighted work
  claim_details     String?
  status            String    @default("pending") @db.VarChar(20) // pending, processing, resolved, rejected
  resolved_at       DateTime? @db.Timestamptz(6)
  resolution_note   String?
  processed_by      String?   @db.Uuid
  created_at        DateTime  @default(now()) @db.Timestamptz(6)
  updated_at        DateTime  @default(now()) @db.Timestamptz(6)

  target_link   ChapterLink? @relation(fields: [target_link_id], references: [id], onDelete: SetNull)
  target_series Series?      @relation(fields: [target_series_id], references: [id], onDelete: SetNull)
  processor     User?        @relation("dmca_processor", fields: [processed_by], references: [id], onDelete: SetNull)

  @@index([status, created_at(sort: Asc)])
  @@index([target_link_id])
  @@map("dmca_requests")
}

// Append-only audit log for link operations (Safe Harbor compliance)
// RULE: INSERT ONLY - never update or delete records (enforced by DB trigger)
model LinkSubmissionAudit {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  chapter_link_id String?  @db.Uuid
  action          String   @db.VarChar(50) // submit, approve, reject, report, remove, restore, vote
  actor_id        String?  @db.Uuid
  actor_ip        String?  // IP address for abuse tracking
  payload         Json     @default("{}") // Action-specific data
  created_at      DateTime @default(now()) @db.Timestamptz(6)

  link  ChapterLink? @relation(fields: [chapter_link_id], references: [id], onDelete: SetNull)
  actor User?        @relation(fields: [actor_id], references: [id], onDelete: SetNull)

  @@index([chapter_link_id, created_at(sort: Desc)])
  @@index([actor_id, created_at(sort: Desc)])
  @@index([action, created_at(sort: Desc)])
  @@map("link_submission_audit")
}

// Blocked domains (malware, phishing, DMCA repeat offenders)
model DomainBlacklist {
  domain     String    @id @db.VarChar(255)
  reason     String    @db.VarChar(100) // malware, phishing, dmca_repeat, spam
  added_by   String?   @db.Uuid
  added_at   DateTime  @default(now()) @db.Timestamptz(6)
  expires_at DateTime? @db.Timestamptz(6) // Optional expiration
  notes      String?

  user User? @relation(fields: [added_by], references: [id], onDelete: SetNull)

  @@map("domain_blacklist")
}
